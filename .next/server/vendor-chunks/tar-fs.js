/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar-fs";
exports.ids = ["vendor-chunks/tar-fs"];
exports.modules = {

/***/ "(rsc)/./node_modules/tar-fs/index.js":
/*!**************************************!*\
  !*** ./node_modules/tar-fs/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const tar = __webpack_require__(/*! tar-stream */ \"(rsc)/./node_modules/tar-stream/index.js\");\nconst pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst win32 = (global.Bare?.platform || process.platform) === \"win32\";\nexports.pack = function pack(cwd, opts) {\n    if (!cwd) cwd = \".\";\n    if (!opts) opts = {};\n    const xfs = opts.fs || fs;\n    const ignore = opts.ignore || opts.filter || noop;\n    const mapStream = opts.mapStream || echo;\n    const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);\n    const strict = opts.strict !== false;\n    const umask = typeof opts.umask === \"number\" ? ~opts.umask : ~processUmask();\n    const pack = opts.pack || tar.pack();\n    const finish = opts.finish || noop;\n    let map = opts.map || noop;\n    let dmode = typeof opts.dmode === \"number\" ? opts.dmode : 0;\n    let fmode = typeof opts.fmode === \"number\" ? opts.fmode : 0;\n    if (opts.strip) map = strip(map, opts.strip);\n    if (opts.readable) {\n        dmode |= parseInt(555, 8);\n        fmode |= parseInt(444, 8);\n    }\n    if (opts.writable) {\n        dmode |= parseInt(333, 8);\n        fmode |= parseInt(222, 8);\n    }\n    onnextentry();\n    function onsymlink(filename, header) {\n        xfs.readlink(path.join(cwd, filename), function(err, linkname) {\n            if (err) return pack.destroy(err);\n            header.linkname = normalize(linkname);\n            pack.entry(header, onnextentry);\n        });\n    }\n    function onstat(err, filename, stat) {\n        if (pack.destroyed) return;\n        if (err) return pack.destroy(err);\n        if (!filename) {\n            if (opts.finalize !== false) pack.finalize();\n            return finish(pack);\n        }\n        if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n        ;\n        let header = {\n            name: normalize(filename),\n            mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n            mtime: stat.mtime,\n            size: stat.size,\n            type: \"file\",\n            uid: stat.uid,\n            gid: stat.gid\n        };\n        if (stat.isDirectory()) {\n            header.size = 0;\n            header.type = \"directory\";\n            header = map(header) || header;\n            return pack.entry(header, onnextentry);\n        }\n        if (stat.isSymbolicLink()) {\n            header.size = 0;\n            header.type = \"symlink\";\n            header = map(header) || header;\n            return onsymlink(filename, header);\n        }\n        // TODO: add fifo etc...\n        header = map(header) || header;\n        if (!stat.isFile()) {\n            if (strict) return pack.destroy(new Error(\"unsupported type for \" + filename));\n            return onnextentry();\n        }\n        const entry = pack.entry(header, onnextentry);\n        const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), {\n            start: 0,\n            end: header.size > 0 ? header.size - 1 : header.size\n        }), header);\n        rs.on(\"error\", function(err) {\n            entry.destroy(err);\n        });\n        pump(rs, entry);\n    }\n    function onnextentry(err) {\n        if (err) return pack.destroy(err);\n        statNext(onstat);\n    }\n    return pack;\n};\nfunction head(list) {\n    return list.length ? list[list.length - 1] : null;\n}\nfunction processGetuid() {\n    return process.getuid ? process.getuid() : -1;\n}\nfunction processUmask() {\n    return process.umask ? process.umask() : 0;\n}\nexports.extract = function extract(cwd, opts) {\n    if (!cwd) cwd = \".\";\n    if (!opts) opts = {};\n    cwd = path.resolve(cwd);\n    const xfs = opts.fs || fs;\n    const ignore = opts.ignore || opts.filter || noop;\n    const mapStream = opts.mapStream || echo;\n    const own = opts.chown !== false && !win32 && processGetuid() === 0;\n    const extract = opts.extract || tar.extract();\n    const stack = [];\n    const now = new Date();\n    const umask = typeof opts.umask === \"number\" ? ~opts.umask : ~processUmask();\n    const strict = opts.strict !== false;\n    let map = opts.map || noop;\n    let dmode = typeof opts.dmode === \"number\" ? opts.dmode : 0;\n    let fmode = typeof opts.fmode === \"number\" ? opts.fmode : 0;\n    if (opts.strip) map = strip(map, opts.strip);\n    if (opts.readable) {\n        dmode |= parseInt(555, 8);\n        fmode |= parseInt(444, 8);\n    }\n    if (opts.writable) {\n        dmode |= parseInt(333, 8);\n        fmode |= parseInt(222, 8);\n    }\n    extract.on(\"entry\", onentry);\n    if (opts.finish) extract.on(\"finish\", opts.finish);\n    return extract;\n    function onentry(header, stream, next) {\n        header = map(header) || header;\n        header.name = normalize(header.name);\n        const name = path.join(cwd, path.join(\"/\", header.name));\n        if (ignore(name, header)) {\n            stream.resume();\n            return next();\n        }\n        const dir = path.join(name, \".\") === path.join(cwd, \".\") ? cwd : path.dirname(name);\n        validate(xfs, dir, path.join(cwd, \".\"), function(err, valid) {\n            if (err) return next(err);\n            if (!valid) return next(new Error(dir + \" is not a valid path\"));\n            if (header.type === \"directory\") {\n                stack.push([\n                    name,\n                    header.mtime\n                ]);\n                return mkdirfix(name, {\n                    fs: xfs,\n                    own,\n                    uid: header.uid,\n                    gid: header.gid,\n                    mode: header.mode\n                }, stat);\n            }\n            mkdirfix(dir, {\n                fs: xfs,\n                own,\n                uid: header.uid,\n                gid: header.gid,\n                // normally, the folders with rights and owner should be part of the TAR file\n                // if this is not the case, create folder for same user as file and with\n                // standard permissions of 0o755 (rwxr-xr-x)\n                mode: 493\n            }, function(err) {\n                if (err) return next(err);\n                switch(header.type){\n                    case \"file\":\n                        return onfile();\n                    case \"link\":\n                        return onlink();\n                    case \"symlink\":\n                        return onsymlink();\n                }\n                if (strict) return next(new Error(\"unsupported type for \" + name + \" (\" + header.type + \")\"));\n                stream.resume();\n                next();\n            });\n        });\n        function stat(err) {\n            if (err) return next(err);\n            utimes(name, header, function(err) {\n                if (err) return next(err);\n                if (win32) return next();\n                chperm(name, header, next);\n            });\n        }\n        function onsymlink() {\n            if (win32) return next() // skip symlinks on win for now before it can be tested\n            ;\n            xfs.unlink(name, function() {\n                const dst = path.resolve(path.dirname(name), header.linkname);\n                if (!inCwd(dst)) return next(new Error(name + \" is not a valid symlink\"));\n                xfs.symlink(header.linkname, name, stat);\n            });\n        }\n        function onlink() {\n            if (win32) return next() // skip links on win for now before it can be tested\n            ;\n            xfs.unlink(name, function() {\n                const link = path.join(cwd, path.join(\"/\", header.linkname));\n                fs.realpath(link, function(err, dst) {\n                    if (err || !inCwd(dst)) return next(new Error(name + \" is not a valid hardlink\"));\n                    xfs.link(dst, name, function(err) {\n                        if (err && err.code === \"EPERM\" && opts.hardlinkAsFilesFallback) {\n                            stream = xfs.createReadStream(dst);\n                            return onfile();\n                        }\n                        stat(err);\n                    });\n                });\n            });\n        }\n        function inCwd(dst) {\n            return dst.startsWith(cwd);\n        }\n        function onfile() {\n            const ws = xfs.createWriteStream(name);\n            const rs = mapStream(stream, header);\n            ws.on(\"error\", function(err) {\n                rs.destroy(err);\n            });\n            pump(rs, ws, function(err) {\n                if (err) return next(err);\n                ws.on(\"close\", stat);\n            });\n        }\n    }\n    function utimesParent(name, cb) {\n        let top;\n        while((top = head(stack)) && name.slice(0, top[0].length) !== top[0])stack.pop();\n        if (!top) return cb();\n        xfs.utimes(top[0], now, top[1], cb);\n    }\n    function utimes(name, header, cb) {\n        if (opts.utimes === false) return cb();\n        if (header.type === \"directory\") return xfs.utimes(name, now, header.mtime, cb);\n        if (header.type === \"symlink\") return utimesParent(name, cb) // TODO: how to set mtime on link?\n        ;\n        xfs.utimes(name, now, header.mtime, function(err) {\n            if (err) return cb(err);\n            utimesParent(name, cb);\n        });\n    }\n    function chperm(name, header, cb) {\n        const link = header.type === \"symlink\";\n        /* eslint-disable n/no-deprecated-api */ const chmod = link ? xfs.lchmod : xfs.chmod;\n        const chown = link ? xfs.lchown : xfs.chown;\n        /* eslint-enable n/no-deprecated-api */ if (!chmod) return cb();\n        const mode = (header.mode | (header.type === \"directory\" ? dmode : fmode)) & umask;\n        if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown);\n        else onchown(null);\n        function onchown(err) {\n            if (err) return cb(err);\n            if (!chmod) return cb();\n            chmod.call(xfs, name, mode, cb);\n        }\n    }\n    function mkdirfix(name, opts, cb) {\n        // when mkdir is called on an existing directory, the permissions\n        // will be overwritten (?), to avoid this we check for its existance first\n        xfs.stat(name, function(err) {\n            if (!err) return cb(null);\n            if (err.code !== \"ENOENT\") return cb(err);\n            xfs.mkdir(name, {\n                mode: opts.mode,\n                recursive: true\n            }, function(err, made) {\n                if (err) return cb(err);\n                chperm(name, opts, cb);\n            });\n        });\n    }\n};\nfunction validate(fs, name, root, cb) {\n    if (name === root) return cb(null, true);\n    fs.lstat(name, function(err, st) {\n        if (err && err.code !== \"ENOENT\" && err.code !== \"EPERM\") return cb(err);\n        if (err || st.isDirectory()) return validate(fs, path.join(name, \"..\"), root, cb);\n        cb(null, false);\n    });\n}\nfunction noop() {}\nfunction echo(name) {\n    return name;\n}\nfunction normalize(name) {\n    return win32 ? name.replace(/\\\\/g, \"/\").replace(/[:?<>|]/g, \"_\") : name;\n}\nfunction statAll(fs, stat, cwd, ignore, entries, sort) {\n    if (!entries) entries = [\n        \".\"\n    ];\n    const queue = entries.slice(0);\n    return function loop(callback) {\n        if (!queue.length) return callback(null);\n        const next = queue.shift();\n        const nextAbs = path.join(cwd, next);\n        stat.call(fs, nextAbs, function(err, stat) {\n            // ignore errors if the files were deleted while buffering\n            if (err) return callback(entries.indexOf(next) === -1 && err.code === \"ENOENT\" ? null : err);\n            if (!stat.isDirectory()) return callback(null, next, stat);\n            fs.readdir(nextAbs, function(err, files) {\n                if (err) return callback(err);\n                if (sort) files.sort();\n                for(let i = 0; i < files.length; i++){\n                    if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));\n                }\n                callback(null, next, stat);\n            });\n        });\n    };\n}\nfunction strip(map, level) {\n    return function(header) {\n        header.name = header.name.split(\"/\").slice(level).join(\"/\");\n        const linkname = header.linkname;\n        if (linkname && (header.type === \"link\" || path.isAbsolute(linkname))) {\n            header.linkname = linkname.split(\"/\").slice(level).join(\"/\");\n        }\n        return map(header);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUEsT0FBT1osSUFBSVU7SUFDYjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2lmeS8uL25vZGVfbW9kdWxlcy90YXItZnMvaW5kZXguanM/Y2U2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0YXIgPSByZXF1aXJlKCd0YXItc3RyZWFtJylcbmNvbnN0IHB1bXAgPSByZXF1aXJlKCdwdW1wJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCB3aW4zMiA9IChnbG9iYWwuQmFyZT8ucGxhdGZvcm0gfHwgcHJvY2Vzcy5wbGF0Zm9ybSkgPT09ICd3aW4zMidcblxuZXhwb3J0cy5wYWNrID0gZnVuY3Rpb24gcGFjayAoY3dkLCBvcHRzKSB7XG4gIGlmICghY3dkKSBjd2QgPSAnLidcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG4gIGNvbnN0IGlnbm9yZSA9IG9wdHMuaWdub3JlIHx8IG9wdHMuZmlsdGVyIHx8IG5vb3BcbiAgY29uc3QgbWFwU3RyZWFtID0gb3B0cy5tYXBTdHJlYW0gfHwgZWNob1xuICBjb25zdCBzdGF0TmV4dCA9IHN0YXRBbGwoeGZzLCBvcHRzLmRlcmVmZXJlbmNlID8geGZzLnN0YXQgOiB4ZnMubHN0YXQsIGN3ZCwgaWdub3JlLCBvcHRzLmVudHJpZXMsIG9wdHMuc29ydClcbiAgY29uc3Qgc3RyaWN0ID0gb3B0cy5zdHJpY3QgIT09IGZhbHNlXG4gIGNvbnN0IHVtYXNrID0gdHlwZW9mIG9wdHMudW1hc2sgPT09ICdudW1iZXInID8gfm9wdHMudW1hc2sgOiB+cHJvY2Vzc1VtYXNrKClcbiAgY29uc3QgcGFjayA9IG9wdHMucGFjayB8fCB0YXIucGFjaygpXG4gIGNvbnN0IGZpbmlzaCA9IG9wdHMuZmluaXNoIHx8IG5vb3BcblxuICBsZXQgbWFwID0gb3B0cy5tYXAgfHwgbm9vcFxuICBsZXQgZG1vZGUgPSB0eXBlb2Ygb3B0cy5kbW9kZSA9PT0gJ251bWJlcicgPyBvcHRzLmRtb2RlIDogMFxuICBsZXQgZm1vZGUgPSB0eXBlb2Ygb3B0cy5mbW9kZSA9PT0gJ251bWJlcicgPyBvcHRzLmZtb2RlIDogMFxuXG4gIGlmIChvcHRzLnN0cmlwKSBtYXAgPSBzdHJpcChtYXAsIG9wdHMuc3RyaXApXG5cbiAgaWYgKG9wdHMucmVhZGFibGUpIHtcbiAgICBkbW9kZSB8PSBwYXJzZUludCg1NTUsIDgpXG4gICAgZm1vZGUgfD0gcGFyc2VJbnQoNDQ0LCA4KVxuICB9XG4gIGlmIChvcHRzLndyaXRhYmxlKSB7XG4gICAgZG1vZGUgfD0gcGFyc2VJbnQoMzMzLCA4KVxuICAgIGZtb2RlIHw9IHBhcnNlSW50KDIyMiwgOClcbiAgfVxuXG4gIG9ubmV4dGVudHJ5KClcblxuICBmdW5jdGlvbiBvbnN5bWxpbmsgKGZpbGVuYW1lLCBoZWFkZXIpIHtcbiAgICB4ZnMucmVhZGxpbmsocGF0aC5qb2luKGN3ZCwgZmlsZW5hbWUpLCBmdW5jdGlvbiAoZXJyLCBsaW5rbmFtZSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHBhY2suZGVzdHJveShlcnIpXG4gICAgICBoZWFkZXIubGlua25hbWUgPSBub3JtYWxpemUobGlua25hbWUpXG4gICAgICBwYWNrLmVudHJ5KGhlYWRlciwgb25uZXh0ZW50cnkpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uc3RhdCAoZXJyLCBmaWxlbmFtZSwgc3RhdCkge1xuICAgIGlmIChwYWNrLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHBhY2suZGVzdHJveShlcnIpXG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgaWYgKG9wdHMuZmluYWxpemUgIT09IGZhbHNlKSBwYWNrLmZpbmFsaXplKClcbiAgICAgIHJldHVybiBmaW5pc2gocGFjaylcbiAgICB9XG5cbiAgICBpZiAoc3RhdC5pc1NvY2tldCgpKSByZXR1cm4gb25uZXh0ZW50cnkoKSAvLyB0YXIgZG9lcyBub3Qgc3VwcG9ydCBzb2NrZXRzLi4uXG5cbiAgICBsZXQgaGVhZGVyID0ge1xuICAgICAgbmFtZTogbm9ybWFsaXplKGZpbGVuYW1lKSxcbiAgICAgIG1vZGU6IChzdGF0Lm1vZGUgfCAoc3RhdC5pc0RpcmVjdG9yeSgpID8gZG1vZGUgOiBmbW9kZSkpICYgdW1hc2ssXG4gICAgICBtdGltZTogc3RhdC5tdGltZSxcbiAgICAgIHNpemU6IHN0YXQuc2l6ZSxcbiAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgIHVpZDogc3RhdC51aWQsXG4gICAgICBnaWQ6IHN0YXQuZ2lkXG4gICAgfVxuXG4gICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaGVhZGVyLnNpemUgPSAwXG4gICAgICBoZWFkZXIudHlwZSA9ICdkaXJlY3RvcnknXG4gICAgICBoZWFkZXIgPSBtYXAoaGVhZGVyKSB8fCBoZWFkZXJcbiAgICAgIHJldHVybiBwYWNrLmVudHJ5KGhlYWRlciwgb25uZXh0ZW50cnkpXG4gICAgfVxuXG4gICAgaWYgKHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgaGVhZGVyLnNpemUgPSAwXG4gICAgICBoZWFkZXIudHlwZSA9ICdzeW1saW5rJ1xuICAgICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG4gICAgICByZXR1cm4gb25zeW1saW5rKGZpbGVuYW1lLCBoZWFkZXIpXG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIGZpZm8gZXRjLi4uXG5cbiAgICBoZWFkZXIgPSBtYXAoaGVhZGVyKSB8fCBoZWFkZXJcblxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIHBhY2suZGVzdHJveShuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yICcgKyBmaWxlbmFtZSkpXG4gICAgICByZXR1cm4gb25uZXh0ZW50cnkoKVxuICAgIH1cblxuICAgIGNvbnN0IGVudHJ5ID0gcGFjay5lbnRyeShoZWFkZXIsIG9ubmV4dGVudHJ5KVxuICAgIGNvbnN0IHJzID0gbWFwU3RyZWFtKHhmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGguam9pbihjd2QsIGZpbGVuYW1lKSwgeyBzdGFydDogMCwgZW5kOiBoZWFkZXIuc2l6ZSA+IDAgPyBoZWFkZXIuc2l6ZSAtIDEgOiBoZWFkZXIuc2l6ZSB9KSwgaGVhZGVyKVxuXG4gICAgcnMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyAvLyBhbHdheXMgZm9yd2FyZCBlcnJvcnMgb24gZGVzdHJveVxuICAgICAgZW50cnkuZGVzdHJveShlcnIpXG4gICAgfSlcblxuICAgIHB1bXAocnMsIGVudHJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gb25uZXh0ZW50cnkgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBwYWNrLmRlc3Ryb3koZXJyKVxuICAgIHN0YXROZXh0KG9uc3RhdClcbiAgfVxuXG4gIHJldHVybiBwYWNrXG59XG5cbmZ1bmN0aW9uIGhlYWQgKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubGVuZ3RoID8gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdIDogbnVsbFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2V0dWlkICgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZ2V0dWlkID8gcHJvY2Vzcy5nZXR1aWQoKSA6IC0xXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVbWFzayAoKSB7XG4gIHJldHVybiBwcm9jZXNzLnVtYXNrID8gcHJvY2Vzcy51bWFzaygpIDogMFxufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0IChjd2QsIG9wdHMpIHtcbiAgaWYgKCFjd2QpIGN3ZCA9ICcuJ1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIGN3ZCA9IHBhdGgucmVzb2x2ZShjd2QpXG5cbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuICBjb25zdCBpZ25vcmUgPSBvcHRzLmlnbm9yZSB8fCBvcHRzLmZpbHRlciB8fCBub29wXG4gIGNvbnN0IG1hcFN0cmVhbSA9IG9wdHMubWFwU3RyZWFtIHx8IGVjaG9cbiAgY29uc3Qgb3duID0gb3B0cy5jaG93biAhPT0gZmFsc2UgJiYgIXdpbjMyICYmIHByb2Nlc3NHZXR1aWQoKSA9PT0gMFxuICBjb25zdCBleHRyYWN0ID0gb3B0cy5leHRyYWN0IHx8IHRhci5leHRyYWN0KClcbiAgY29uc3Qgc3RhY2sgPSBbXVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IHVtYXNrID0gdHlwZW9mIG9wdHMudW1hc2sgPT09ICdudW1iZXInID8gfm9wdHMudW1hc2sgOiB+cHJvY2Vzc1VtYXNrKClcbiAgY29uc3Qgc3RyaWN0ID0gb3B0cy5zdHJpY3QgIT09IGZhbHNlXG5cbiAgbGV0IG1hcCA9IG9wdHMubWFwIHx8IG5vb3BcbiAgbGV0IGRtb2RlID0gdHlwZW9mIG9wdHMuZG1vZGUgPT09ICdudW1iZXInID8gb3B0cy5kbW9kZSA6IDBcbiAgbGV0IGZtb2RlID0gdHlwZW9mIG9wdHMuZm1vZGUgPT09ICdudW1iZXInID8gb3B0cy5mbW9kZSA6IDBcblxuICBpZiAob3B0cy5zdHJpcCkgbWFwID0gc3RyaXAobWFwLCBvcHRzLnN0cmlwKVxuXG4gIGlmIChvcHRzLnJlYWRhYmxlKSB7XG4gICAgZG1vZGUgfD0gcGFyc2VJbnQoNTU1LCA4KVxuICAgIGZtb2RlIHw9IHBhcnNlSW50KDQ0NCwgOClcbiAgfVxuICBpZiAob3B0cy53cml0YWJsZSkge1xuICAgIGRtb2RlIHw9IHBhcnNlSW50KDMzMywgOClcbiAgICBmbW9kZSB8PSBwYXJzZUludCgyMjIsIDgpXG4gIH1cblxuICBleHRyYWN0Lm9uKCdlbnRyeScsIG9uZW50cnkpXG5cbiAgaWYgKG9wdHMuZmluaXNoKSBleHRyYWN0Lm9uKCdmaW5pc2gnLCBvcHRzLmZpbmlzaClcblxuICByZXR1cm4gZXh0cmFjdFxuXG4gIGZ1bmN0aW9uIG9uZW50cnkgKGhlYWRlciwgc3RyZWFtLCBuZXh0KSB7XG4gICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG4gICAgaGVhZGVyLm5hbWUgPSBub3JtYWxpemUoaGVhZGVyLm5hbWUpXG5cbiAgICBjb25zdCBuYW1lID0gcGF0aC5qb2luKGN3ZCwgcGF0aC5qb2luKCcvJywgaGVhZGVyLm5hbWUpKVxuXG4gICAgaWYgKGlnbm9yZShuYW1lLCBoZWFkZXIpKSB7XG4gICAgICBzdHJlYW0ucmVzdW1lKClcbiAgICAgIHJldHVybiBuZXh0KClcbiAgICB9XG5cbiAgICBjb25zdCBkaXIgPSBwYXRoLmpvaW4obmFtZSwgJy4nKSA9PT0gcGF0aC5qb2luKGN3ZCwgJy4nKSA/IGN3ZCA6IHBhdGguZGlybmFtZShuYW1lKVxuXG4gICAgdmFsaWRhdGUoeGZzLCBkaXIsIHBhdGguam9pbihjd2QsICcuJyksIGZ1bmN0aW9uIChlcnIsIHZhbGlkKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gbmV4dChuZXcgRXJyb3IoZGlyICsgJyBpcyBub3QgYSB2YWxpZCBwYXRoJykpXG5cbiAgICAgIGlmIChoZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgc3RhY2sucHVzaChbbmFtZSwgaGVhZGVyLm10aW1lXSlcbiAgICAgICAgcmV0dXJuIG1rZGlyZml4KG5hbWUsIHtcbiAgICAgICAgICBmczogeGZzLFxuICAgICAgICAgIG93bixcbiAgICAgICAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgICAgICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgICAgICAgIG1vZGU6IGhlYWRlci5tb2RlXG4gICAgICAgIH0sIHN0YXQpXG4gICAgICB9XG5cbiAgICAgIG1rZGlyZml4KGRpciwge1xuICAgICAgICBmczogeGZzLFxuICAgICAgICBvd24sXG4gICAgICAgIHVpZDogaGVhZGVyLnVpZCxcbiAgICAgICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgICAgICAvLyBub3JtYWxseSwgdGhlIGZvbGRlcnMgd2l0aCByaWdodHMgYW5kIG93bmVyIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBUQVIgZmlsZVxuICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgY3JlYXRlIGZvbGRlciBmb3Igc2FtZSB1c2VyIGFzIGZpbGUgYW5kIHdpdGhcbiAgICAgICAgLy8gc3RhbmRhcmQgcGVybWlzc2lvbnMgb2YgMG83NTUgKHJ3eHIteHIteClcbiAgICAgICAgbW9kZTogMG83NTVcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdmaWxlJzogcmV0dXJuIG9uZmlsZSgpXG4gICAgICAgICAgY2FzZSAnbGluayc6IHJldHVybiBvbmxpbmsoKVxuICAgICAgICAgIGNhc2UgJ3N5bWxpbmsnOiByZXR1cm4gb25zeW1saW5rKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBuZXh0KG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdHlwZSBmb3IgJyArIG5hbWUgKyAnICgnICsgaGVhZGVyLnR5cGUgKyAnKScpKVxuXG4gICAgICAgIHN0cmVhbS5yZXN1bWUoKVxuICAgICAgICBuZXh0KClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIHN0YXQgKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuICAgICAgdXRpbWVzKG5hbWUsIGhlYWRlciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICAgIGlmICh3aW4zMikgcmV0dXJuIG5leHQoKVxuICAgICAgICBjaHBlcm0obmFtZSwgaGVhZGVyLCBuZXh0KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbnN5bWxpbmsgKCkge1xuICAgICAgaWYgKHdpbjMyKSByZXR1cm4gbmV4dCgpIC8vIHNraXAgc3ltbGlua3Mgb24gd2luIGZvciBub3cgYmVmb3JlIGl0IGNhbiBiZSB0ZXN0ZWRcbiAgICAgIHhmcy51bmxpbmsobmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkc3QgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKG5hbWUpLCBoZWFkZXIubGlua25hbWUpXG4gICAgICAgIGlmICghaW5Dd2QoZHN0KSkgcmV0dXJuIG5leHQobmV3IEVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIHZhbGlkIHN5bWxpbmsnKSlcblxuICAgICAgICB4ZnMuc3ltbGluayhoZWFkZXIubGlua25hbWUsIG5hbWUsIHN0YXQpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubGluayAoKSB7XG4gICAgICBpZiAod2luMzIpIHJldHVybiBuZXh0KCkgLy8gc2tpcCBsaW5rcyBvbiB3aW4gZm9yIG5vdyBiZWZvcmUgaXQgY2FuIGJlIHRlc3RlZFxuICAgICAgeGZzLnVubGluayhuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBwYXRoLmpvaW4oY3dkLCBwYXRoLmpvaW4oJy8nLCBoZWFkZXIubGlua25hbWUpKVxuXG4gICAgICAgIGZzLnJlYWxwYXRoKGxpbmssIGZ1bmN0aW9uIChlcnIsIGRzdCkge1xuICAgICAgICAgIGlmIChlcnIgfHwgIWluQ3dkKGRzdCkpIHJldHVybiBuZXh0KG5ldyBFcnJvcihuYW1lICsgJyBpcyBub3QgYSB2YWxpZCBoYXJkbGluaycpKVxuXG4gICAgICAgICAgeGZzLmxpbmsoZHN0LCBuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRVBFUk0nICYmIG9wdHMuaGFyZGxpbmtBc0ZpbGVzRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgc3RyZWFtID0geGZzLmNyZWF0ZVJlYWRTdHJlYW0oZHN0KVxuICAgICAgICAgICAgICByZXR1cm4gb25maWxlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdChlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5Dd2QgKGRzdCkge1xuICAgICAgcmV0dXJuIGRzdC5zdGFydHNXaXRoKGN3ZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmZpbGUgKCkge1xuICAgICAgY29uc3Qgd3MgPSB4ZnMuY3JlYXRlV3JpdGVTdHJlYW0obmFtZSlcbiAgICAgIGNvbnN0IHJzID0gbWFwU3RyZWFtKHN0cmVhbSwgaGVhZGVyKVxuXG4gICAgICB3cy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IC8vIGFsd2F5cyBmb3J3YXJkIGVycm9ycyBvbiBkZXN0cm95XG4gICAgICAgIHJzLmRlc3Ryb3koZXJyKVxuICAgICAgfSlcblxuICAgICAgcHVtcChycywgd3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuICAgICAgICB3cy5vbignY2xvc2UnLCBzdGF0KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1dGltZXNQYXJlbnQgKG5hbWUsIGNiKSB7IC8vIHdlIGp1c3Qgc2V0IHRoZSBtdGltZSBvbiB0aGUgcGFyZW50IGRpciBhZ2FpbiBldmVyeXRpbWUgd2Ugd3JpdGUgYW4gZW50cnlcbiAgICBsZXQgdG9wXG4gICAgd2hpbGUgKCh0b3AgPSBoZWFkKHN0YWNrKSkgJiYgbmFtZS5zbGljZSgwLCB0b3BbMF0ubGVuZ3RoKSAhPT0gdG9wWzBdKSBzdGFjay5wb3AoKVxuICAgIGlmICghdG9wKSByZXR1cm4gY2IoKVxuICAgIHhmcy51dGltZXModG9wWzBdLCBub3csIHRvcFsxXSwgY2IpXG4gIH1cblxuICBmdW5jdGlvbiB1dGltZXMgKG5hbWUsIGhlYWRlciwgY2IpIHtcbiAgICBpZiAob3B0cy51dGltZXMgPT09IGZhbHNlKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKGhlYWRlci50eXBlID09PSAnZGlyZWN0b3J5JykgcmV0dXJuIHhmcy51dGltZXMobmFtZSwgbm93LCBoZWFkZXIubXRpbWUsIGNiKVxuICAgIGlmIChoZWFkZXIudHlwZSA9PT0gJ3N5bWxpbmsnKSByZXR1cm4gdXRpbWVzUGFyZW50KG5hbWUsIGNiKSAvLyBUT0RPOiBob3cgdG8gc2V0IG10aW1lIG9uIGxpbms/XG5cbiAgICB4ZnMudXRpbWVzKG5hbWUsIG5vdywgaGVhZGVyLm10aW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgdXRpbWVzUGFyZW50KG5hbWUsIGNiKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjaHBlcm0gKG5hbWUsIGhlYWRlciwgY2IpIHtcbiAgICBjb25zdCBsaW5rID0gaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJ1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbi9uby1kZXByZWNhdGVkLWFwaSAqL1xuICAgIGNvbnN0IGNobW9kID0gbGluayA/IHhmcy5sY2htb2QgOiB4ZnMuY2htb2RcbiAgICBjb25zdCBjaG93biA9IGxpbmsgPyB4ZnMubGNob3duIDogeGZzLmNob3duXG4gICAgLyogZXNsaW50LWVuYWJsZSBuL25vLWRlcHJlY2F0ZWQtYXBpICovXG5cbiAgICBpZiAoIWNobW9kKSByZXR1cm4gY2IoKVxuXG4gICAgY29uc3QgbW9kZSA9IChoZWFkZXIubW9kZSB8IChoZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScgPyBkbW9kZSA6IGZtb2RlKSkgJiB1bWFza1xuXG4gICAgaWYgKGNob3duICYmIG93bikgY2hvd24uY2FsbCh4ZnMsIG5hbWUsIGhlYWRlci51aWQsIGhlYWRlci5naWQsIG9uY2hvd24pXG4gICAgZWxzZSBvbmNob3duKG51bGwpXG5cbiAgICBmdW5jdGlvbiBvbmNob3duIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAoIWNobW9kKSByZXR1cm4gY2IoKVxuICAgICAgY2htb2QuY2FsbCh4ZnMsIG5hbWUsIG1vZGUsIGNiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1rZGlyZml4IChuYW1lLCBvcHRzLCBjYikge1xuICAgIC8vIHdoZW4gbWtkaXIgaXMgY2FsbGVkIG9uIGFuIGV4aXN0aW5nIGRpcmVjdG9yeSwgdGhlIHBlcm1pc3Npb25zXG4gICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiAoPyksIHRvIGF2b2lkIHRoaXMgd2UgY2hlY2sgZm9yIGl0cyBleGlzdGFuY2UgZmlyc3RcbiAgICB4ZnMuc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycikgcmV0dXJuIGNiKG51bGwpXG4gICAgICBpZiAoZXJyLmNvZGUgIT09ICdFTk9FTlQnKSByZXR1cm4gY2IoZXJyKVxuICAgICAgeGZzLm1rZGlyKG5hbWUsIHsgbW9kZTogb3B0cy5tb2RlLCByZWN1cnNpdmU6IHRydWUgfSwgZnVuY3Rpb24gKGVyciwgbWFkZSkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICBjaHBlcm0obmFtZSwgb3B0cywgY2IpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUgKGZzLCBuYW1lLCByb290LCBjYikge1xuICBpZiAobmFtZSA9PT0gcm9vdCkgcmV0dXJuIGNiKG51bGwsIHRydWUpXG5cbiAgZnMubHN0YXQobmFtZSwgZnVuY3Rpb24gKGVyciwgc3QpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRU5PRU5UJyAmJiBlcnIuY29kZSAhPT0gJ0VQRVJNJykgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZXJyIHx8IHN0LmlzRGlyZWN0b3J5KCkpIHJldHVybiB2YWxpZGF0ZShmcywgcGF0aC5qb2luKG5hbWUsICcuLicpLCByb290LCBjYilcbiAgICBjYihudWxsLCBmYWxzZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBlY2hvIChuYW1lKSB7XG4gIHJldHVybiBuYW1lXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAobmFtZSkge1xuICByZXR1cm4gd2luMzIgPyBuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9bOj88PnxdL2csICdfJykgOiBuYW1lXG59XG5cbmZ1bmN0aW9uIHN0YXRBbGwgKGZzLCBzdGF0LCBjd2QsIGlnbm9yZSwgZW50cmllcywgc29ydCkge1xuICBpZiAoIWVudHJpZXMpIGVudHJpZXMgPSBbJy4nXVxuICBjb25zdCBxdWV1ZSA9IGVudHJpZXMuc2xpY2UoMClcblxuICByZXR1cm4gZnVuY3Rpb24gbG9vcCAoY2FsbGJhY2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG5cbiAgICBjb25zdCBuZXh0ID0gcXVldWUuc2hpZnQoKVxuICAgIGNvbnN0IG5leHRBYnMgPSBwYXRoLmpvaW4oY3dkLCBuZXh0KVxuXG4gICAgc3RhdC5jYWxsKGZzLCBuZXh0QWJzLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzIGlmIHRoZSBmaWxlcyB3ZXJlIGRlbGV0ZWQgd2hpbGUgYnVmZmVyaW5nXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZW50cmllcy5pbmRleE9mKG5leHQpID09PSAtMSAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXJyKVxuXG4gICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5leHQsIHN0YXQpXG5cbiAgICAgIGZzLnJlYWRkaXIobmV4dEFicywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgICBpZiAoc29ydCkgZmlsZXMuc29ydCgpXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghaWdub3JlKHBhdGguam9pbihjd2QsIG5leHQsIGZpbGVzW2ldKSkpIHF1ZXVlLnB1c2gocGF0aC5qb2luKG5leHQsIGZpbGVzW2ldKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIG5leHQsIHN0YXQpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXAgKG1hcCwgbGV2ZWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICBoZWFkZXIubmFtZSA9IGhlYWRlci5uYW1lLnNwbGl0KCcvJykuc2xpY2UobGV2ZWwpLmpvaW4oJy8nKVxuXG4gICAgY29uc3QgbGlua25hbWUgPSBoZWFkZXIubGlua25hbWVcbiAgICBpZiAobGlua25hbWUgJiYgKGhlYWRlci50eXBlID09PSAnbGluaycgfHwgcGF0aC5pc0Fic29sdXRlKGxpbmtuYW1lKSkpIHtcbiAgICAgIGhlYWRlci5saW5rbmFtZSA9IGxpbmtuYW1lLnNwbGl0KCcvJykuc2xpY2UobGV2ZWwpLmpvaW4oJy8nKVxuICAgIH1cblxuICAgIHJldHVybiBtYXAoaGVhZGVyKVxuICB9XG59XG4iXSwibmFtZXMiOlsidGFyIiwicmVxdWlyZSIsInB1bXAiLCJmcyIsInBhdGgiLCJ3aW4zMiIsImdsb2JhbCIsIkJhcmUiLCJwbGF0Zm9ybSIsInByb2Nlc3MiLCJleHBvcnRzIiwicGFjayIsImN3ZCIsIm9wdHMiLCJ4ZnMiLCJpZ25vcmUiLCJmaWx0ZXIiLCJub29wIiwibWFwU3RyZWFtIiwiZWNobyIsInN0YXROZXh0Iiwic3RhdEFsbCIsImRlcmVmZXJlbmNlIiwic3RhdCIsImxzdGF0IiwiZW50cmllcyIsInNvcnQiLCJzdHJpY3QiLCJ1bWFzayIsInByb2Nlc3NVbWFzayIsImZpbmlzaCIsIm1hcCIsImRtb2RlIiwiZm1vZGUiLCJzdHJpcCIsInJlYWRhYmxlIiwicGFyc2VJbnQiLCJ3cml0YWJsZSIsIm9ubmV4dGVudHJ5Iiwib25zeW1saW5rIiwiZmlsZW5hbWUiLCJoZWFkZXIiLCJyZWFkbGluayIsImpvaW4iLCJlcnIiLCJsaW5rbmFtZSIsImRlc3Ryb3kiLCJub3JtYWxpemUiLCJlbnRyeSIsIm9uc3RhdCIsImRlc3Ryb3llZCIsImZpbmFsaXplIiwiaXNTb2NrZXQiLCJuYW1lIiwibW9kZSIsImlzRGlyZWN0b3J5IiwibXRpbWUiLCJzaXplIiwidHlwZSIsInVpZCIsImdpZCIsImlzU3ltYm9saWNMaW5rIiwiaXNGaWxlIiwiRXJyb3IiLCJycyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJzdGFydCIsImVuZCIsIm9uIiwiaGVhZCIsImxpc3QiLCJsZW5ndGgiLCJwcm9jZXNzR2V0dWlkIiwiZ2V0dWlkIiwiZXh0cmFjdCIsInJlc29sdmUiLCJvd24iLCJjaG93biIsInN0YWNrIiwibm93IiwiRGF0ZSIsIm9uZW50cnkiLCJzdHJlYW0iLCJuZXh0IiwicmVzdW1lIiwiZGlyIiwiZGlybmFtZSIsInZhbGlkYXRlIiwidmFsaWQiLCJwdXNoIiwibWtkaXJmaXgiLCJvbmZpbGUiLCJvbmxpbmsiLCJ1dGltZXMiLCJjaHBlcm0iLCJ1bmxpbmsiLCJkc3QiLCJpbkN3ZCIsInN5bWxpbmsiLCJsaW5rIiwicmVhbHBhdGgiLCJjb2RlIiwiaGFyZGxpbmtBc0ZpbGVzRmFsbGJhY2siLCJzdGFydHNXaXRoIiwid3MiLCJjcmVhdGVXcml0ZVN0cmVhbSIsInV0aW1lc1BhcmVudCIsImNiIiwidG9wIiwic2xpY2UiLCJwb3AiLCJjaG1vZCIsImxjaG1vZCIsImxjaG93biIsImNhbGwiLCJvbmNob3duIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJtYWRlIiwicm9vdCIsInN0IiwicmVwbGFjZSIsInF1ZXVlIiwibG9vcCIsImNhbGxiYWNrIiwic2hpZnQiLCJuZXh0QWJzIiwiaW5kZXhPZiIsInJlYWRkaXIiLCJmaWxlcyIsImkiLCJsZXZlbCIsInNwbGl0IiwiaXNBYnNvbHV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-fs/index.js\n");

/***/ })

};
;