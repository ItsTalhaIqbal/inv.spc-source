"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/use-intl/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./use-intl.cjs.development.js */ \"(ssr)/./node_modules/use-intl/dist/use-intl.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDJJQUF5RDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pZnkvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcz9iOWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi91c2UtaW50bC5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3VzZS1pbnRsLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/use-intl.cjs.development.js":
/*!****************************************************************!*\
  !*** ./node_modules/use-intl/dist/use-intl.cjs.development.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar IntlMessageFormat__default = /*#__PURE__*/_interopDefaultLegacy(IntlMessageFormat);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nexports.IntlErrorCode = void 0;\n(function (IntlErrorCode) {\n  IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n  IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n  IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n  IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n  IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n  IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n  IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n})(exports.IntlErrorCode || (exports.IntlErrorCode = {}));\nvar IntlError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(IntlError, _Error);\n  function IntlError(code, originalMessage) {\n    var _this;\n    var message = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    _this = _Error.call(this, message) || this;\n    _this.code = void 0;\n    _this.originalMessage = void 0;\n    _this.code = code;\n    if (originalMessage) {\n      _this.originalMessage = originalMessage;\n    }\n    return _this;\n  }\n  return IntlError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction setTimeZoneInFormats(formats, timeZone) {\n  if (!formats) return formats;\n  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n  return Object.keys(formats).reduce(function (acc, key) {\n    acc[key] = _extends({\n      timeZone: timeZone\n    }, formats[key]);\n    return acc;\n  }, {});\n}\n/**\r\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\r\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\r\n * include both a time and a date in a value, therefore the separation doesn't\r\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\r\n * to convert the format before `intl-messageformat` can be used.\r\n */\nfunction convertFormatsToIntlMessageFormat(formats, timeZone) {\n  var formatsWithTimeZone = timeZone ? _extends({}, formats, {\n    dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n  }) : formats;\n  var mfDateDefaults = IntlMessageFormat__default[\"default\"].formats.date;\n  var defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n  var mfTimeDefaults = IntlMessageFormat__default[\"default\"].formats.time;\n  var defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n  return _extends({}, formatsWithTimeZone, {\n    date: _extends({}, defaultDateFormats, formatsWithTimeZone == null ? void 0 : formatsWithTimeZone.dateTime),\n    time: _extends({}, defaultTimeFormats, formatsWithTimeZone == null ? void 0 : formatsWithTimeZone.dateTime)\n  });\n}\n\n/**\r\n * Contains defaults that are used for all entry points into the core.\r\n * See also `InitializedIntlConfiguration`.\r\n */\nfunction defaultGetMessageFallback(props) {\n  return [props.namespace, props.key].filter(function (part) {\n    return part != null;\n  }).join('.');\n}\nfunction defaultOnError(error) {\n  console.error(error);\n}\n\nfunction resolvePath(messages, key, namespace) {\n  if (!messages) {\n    throw new Error(\"No messages available at `\" + namespace + \"`.\" );\n  }\n  var message = messages;\n  key.split('.').forEach(function (part) {\n    var next = message[part];\n    if (part == null || next == null) {\n      throw new Error(\"Could not resolve `\" + key + \"` in \" + (namespace ? \"`\" + namespace + \"`\" : 'messages') + \".\" );\n    }\n    message = next;\n  });\n  return message;\n}\nfunction prepareTranslationValues(values) {\n  if (Object.keys(values).length === 0) return undefined;\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  var transformedValues = {};\n  Object.keys(values).forEach(function (key) {\n    var index = 0;\n    var value = values[key];\n    var transformed;\n    if (typeof value === 'function') {\n      transformed = function transformed(chunks) {\n        var result = value(chunks);\n        return React.isValidElement(result) ? React.cloneElement(result, {\n          key: key + index++\n        }) : result;\n      };\n    } else {\n      transformed = value;\n    }\n    transformedValues[key] = transformed;\n  });\n  return transformedValues;\n}\nfunction getMessagesOrError(_ref) {\n  var messages = _ref.messages,\n    namespace = _ref.namespace,\n    _ref$onError = _ref.onError,\n    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError;\n  try {\n    if (!messages) {\n      throw new Error( true ? \"No messages were configured on the provider.\" : 0);\n    }\n    var retrievedMessages = namespace ? resolvePath(messages, namespace) : messages;\n    if (!retrievedMessages) {\n      throw new Error( true ? \"No messages for namespace `\" + namespace + \"` found.\" : 0);\n    }\n    return retrievedMessages;\n  } catch (error) {\n    var intlError = new IntlError(exports.IntlErrorCode.MISSING_MESSAGE, error.message);\n    onError(intlError);\n    return intlError;\n  }\n}\nfunction getPlainMessage(candidate, values) {\n  if (values) return undefined;\n  var unescapedMessage = candidate.replace(/'([{}])/gi, '$1');\n  // Placeholders can be in the message if there are default values,\n  // or if the user has forgotten to provide values. In the latter\n  // case we need to compile the message to receive an error.\n  var hasPlaceholders = /<|{/.test(unescapedMessage);\n  if (!hasPlaceholders) {\n    return unescapedMessage;\n  }\n  return undefined;\n}\nfunction createBaseTranslator(_ref2) {\n  var defaultTranslationValues = _ref2.defaultTranslationValues,\n    globalFormats = _ref2.formats,\n    _ref2$getMessageFallb = _ref2.getMessageFallback,\n    getMessageFallback = _ref2$getMessageFallb === void 0 ? defaultGetMessageFallback : _ref2$getMessageFallb,\n    locale = _ref2.locale,\n    messageFormatCache = _ref2.messageFormatCache,\n    messagesOrError = _ref2.messagesOrError,\n    namespace = _ref2.namespace,\n    onError = _ref2.onError,\n    timeZone = _ref2.timeZone;\n  function getFallbackFromErrorAndNotify(key, code, message) {\n    var error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({\n      error: error,\n      key: key,\n      namespace: namespace\n    });\n  }\n  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key: key,\n        namespace: namespace\n      });\n    }\n    var messages = messagesOrError;\n    var message;\n    try {\n      message = resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n    function joinPath(parts) {\n      return parts.filter(function (part) {\n        return part != null;\n      }).join('.');\n    }\n    var cacheKey = joinPath([locale, namespace, key, String(message)]);\n    var messageFormat;\n    if (messageFormatCache != null && messageFormatCache.has(cacheKey)) {\n      messageFormat = messageFormatCache.get(cacheKey);\n    } else {\n      if (typeof message === 'object') {\n        var code, errorMessage;\n        if (Array.isArray(message)) {\n          code = exports.IntlErrorCode.INVALID_MESSAGE;\n          {\n            errorMessage = \"Message at `\" + joinPath([namespace, key]) + \"` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages\";\n          }\n        } else {\n          code = exports.IntlErrorCode.INSUFFICIENT_PATH;\n          {\n            errorMessage = \"Message at `\" + joinPath([namespace, key]) + \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages\";\n          }\n        }\n        return getFallbackFromErrorAndNotify(key, code, errorMessage);\n      }\n      // Hot path that avoids creating an `IntlMessageFormat` instance\n      var plainMessage = getPlainMessage(message, values);\n      if (plainMessage) return plainMessage;\n      try {\n        messageFormat = new IntlMessageFormat__default[\"default\"](message, locale, convertFormatsToIntlMessageFormat(_extends({}, globalFormats, formats), timeZone));\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.INVALID_MESSAGE, error.message);\n      }\n      messageFormatCache == null || messageFormatCache.set(cacheKey, messageFormat);\n    }\n    try {\n      var formattedMessage = messageFormat.format(\n      // @ts-ignore `intl-messageformat` expects a different format\n      // for rich text elements since a recent minor update. This\n      // needs to be evaluated in detail, possibly also in regards\n      // to be able to format to parts.\n      prepareTranslationValues(_extends({}, defaultTranslationValues, values)));\n      if (formattedMessage == null) {\n        throw new Error( true ? \"Unable to format `\" + key + \"` in \" + (namespace ? \"namespace `\" + namespace + \"`\" : 'messages') : 0);\n      }\n      // Limit the function signature to return strings or React elements\n      return React.isValidElement(formattedMessage) ||\n      // Arrays of React elements\n      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.FORMATTING_ERROR, error.message);\n    }\n  }\n  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    var result = translateBaseFn(key, values, formats);\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.INVALID_MESSAGE, \"The message `\" + key + \"` in \" + (namespace ? \"namespace `\" + namespace + \"`\" : 'messages') + \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\" );\n    }\n    return result;\n  }\n  translateFn.rich = translateBaseFn;\n  translateFn.raw = function ( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key) {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key: key,\n        namespace: namespace\n      });\n    }\n    var messages = messagesOrError;\n    try {\n      return resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n  };\n  return translateFn;\n}\n\n/**\r\n * For the strictly typed messages to work we have to wrap the namespace into\r\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\r\n */\nfunction resolveNamespace(namespace, namespacePrefix) {\n  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);\n}\n\nvar _excluded$3 = [\"getMessageFallback\", \"messages\", \"namespace\", \"onError\"];\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n  var getMessageFallback = _ref.getMessageFallback,\n    messages = _ref.messages,\n    namespace = _ref.namespace,\n    onError = _ref.onError,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix];\n  namespace = resolveNamespace(namespace, namespacePrefix);\n  var translator = createBaseTranslator(_extends({}, rest, {\n    onError: onError,\n    getMessageFallback: getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages: messages,\n      namespace: namespace,\n      onError: onError\n    })\n  }));\n  var originalRich = translator.rich;\n  function base() {\n    return translator.apply(void 0, arguments);\n  }\n  // Augment `t.rich` to return plain strings\n  base.rich = function (key, /** Key value pairs for values to interpolate into the message. */\n  values, formats) {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    var result = originalRich(key, values, formats);\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      var error = new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\" );\n      onError(error);\n      return getMessageFallback({\n        error: error,\n        key: key,\n        namespace: namespace\n      });\n    }\n    return result;\n  };\n  base.raw = translator.raw;\n  return base;\n}\n\nvar _excluded$2 = [\"getMessageFallback\", \"messages\", \"namespace\", \"onError\"];\n/**\r\n * Translates messages from the given namespace by using the ICU syntax.\r\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\r\n *\r\n * If no namespace is provided, all available messages are returned.\r\n * The namespace can also indicate nesting by using a dot\r\n * (e.g. `namespace.Component`).\r\n */\nfunction createTranslator(_ref) {\n  var _ref$getMessageFallba = _ref.getMessageFallback,\n    getMessageFallback = _ref$getMessageFallba === void 0 ? defaultGetMessageFallback : _ref$getMessageFallba,\n    messages = _ref.messages,\n    namespace = _ref.namespace,\n    _ref$onError = _ref.onError,\n    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl(_extends({}, rest, {\n    onError: onError,\n    getMessageFallback: getMessageFallback,\n    messages: {\n      '!': messages\n    },\n    namespace: namespace ? \"!.\" + namespace : '!'\n  }), '!');\n}\n\nvar SECOND = 1;\nvar MINUTE = SECOND * 60;\nvar HOUR = MINUTE * 60;\nvar DAY = HOUR * 24;\nvar WEEK = DAY * 7;\nvar MONTH = DAY * (365 / 12); // Approximation\nvar QUARTER = MONTH * 3;\nvar YEAR = DAY * 365;\nvar UNIT_SECONDS = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n  var absValue = Math.abs(seconds);\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n  var formats = _ref.formats,\n    locale = _ref.locale,\n    globalNow = _ref.now,\n    _ref$onError = _ref.onError,\n    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,\n    globalTimeZone = _ref.timeZone;\n  function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n    var options;\n    if (typeof formatOrOptions === 'string') {\n      var formatName = formatOrOptions;\n      options = typeFormats == null ? void 0 : typeFormats[formatName];\n      if (!options) {\n        var error = new IntlError(exports.IntlErrorCode.MISSING_FORMAT, \"Format `\" + formatName + \"` is not available. You can configure it on the provider or provide custom options.\" );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n    return options;\n  }\n  function getFormattedValue(value, formatOrOptions, typeFormats, formatter) {\n    var options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(value);\n    }\n  }\n  function dateTime( /** If a number is supplied, this is interpreted as a UTC timestamp. */\n  value,\n  /** If a time zone is supplied, the `value` is converted to that time zone.\r\n   * Otherwise the user time zone will be used. */\n  formatOrOptions) {\n    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.dateTime, function (options) {\n      var _options;\n      if (!((_options = options) != null && _options.timeZone)) {\n        if (globalTimeZone) {\n          options = _extends({}, options, {\n            timeZone: globalTimeZone\n          });\n        } else {\n          onError(new IntlError(exports.IntlErrorCode.ENVIRONMENT_FALLBACK,  true ? \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone\" : 0));\n        }\n      }\n      return new Intl.DateTimeFormat(locale, options).format(value);\n    });\n  }\n  function number(value, formatOrOptions) {\n    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.number, function (options) {\n      return new Intl.NumberFormat(locale, options).format(value);\n    });\n  }\n  function getGlobalNow() {\n    if (globalNow) {\n      return globalNow;\n    } else {\n      onError(new IntlError(exports.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now\" ));\n      return new Date();\n    }\n  }\n  function extractNowDate(nowOrOptions) {\n    if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n      return new Date(nowOrOptions);\n    }\n    if ((nowOrOptions == null ? void 0 : nowOrOptions.now) !== undefined) {\n      return new Date(nowOrOptions.now);\n    }\n    return getGlobalNow();\n  }\n  function relativeTime( /** The date time that needs to be formatted. */\n  date, /** The reference point in time to which `date` will be formatted in relation to.  */\n  nowOrOptions) {\n    try {\n      var dateDate = new Date(date);\n      var nowDate = extractNowDate(nowOrOptions);\n      var seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      var unit = typeof nowOrOptions === 'number' || nowOrOptions instanceof Date || (nowOrOptions == null ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;\n      var value = calculateRelativeTimeValue(seconds, unit);\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(date);\n    }\n  }\n  function list(value, formatOrOptions) {\n    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.list, function (options) {\n      return new Intl.ListFormat(locale, options).format(value);\n    });\n  }\n  return {\n    dateTime: dateTime,\n    number: number,\n    relativeTime: relativeTime,\n    list: list\n  };\n}\n\n/** @deprecated Switch to `createFormatter` */\nfunction createIntl() {\n  var formatter = createFormatter.apply(void 0, arguments);\n  return {\n    formatDateTime: formatter.dateTime,\n    formatNumber: formatter.number,\n    formatRelativeTime: formatter.relativeTime\n  };\n}\n\nvar IntlContext = /*#__PURE__*/React.createContext(undefined);\n\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n  Object.entries(messages).forEach(function (_ref) {\n    var key = _ref[0],\n      messageOrMessages = _ref[1];\n    if (key.includes('.')) {\n      var keyLabel = key;\n      if (parentPath) keyLabel += \" (at \" + parentPath + \")\";\n      invalidKeyLabels.push(keyLabel);\n    }\n    if (messageOrMessages != null && typeof messageOrMessages === 'object') {\n      validateMessagesSegment(messageOrMessages, invalidKeyLabels, [parentPath, key].filter(function (part) {\n        return part != null;\n      }).join('.'));\n    }\n  });\n}\nfunction validateMessages(messages, onError) {\n  var invalidKeyLabels = [];\n  validateMessagesSegment(messages, invalidKeyLabels);\n  if (invalidKeyLabels.length > 0) {\n    onError(new IntlError(exports.IntlErrorCode.INVALID_KEY, \"Namespace keys can not contain the character \\\".\\\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid \" + (invalidKeyLabels.length === 1 ? 'key' : 'keys') + \": \" + invalidKeyLabels.join(', ') + \"\\n\\nIf you're migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \\\"lodash\\\";\\n\\nconst input = {\\n  \\\"one.one\\\": \\\"1.1\\\",\\n  \\\"one.two\\\": \\\"1.2\\\",\\n  \\\"two.one.one\\\": \\\"2.1.1\\\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \\\"one\\\": {\\n//     \\\"one\\\": \\\"1.1\\\",\\n//     \\\"two\\\": \\\"1.2\\\"\\n//   },\\n//   \\\"two\\\": {\\n//     \\\"one\\\": {\\n//       \\\"one\\\": \\\"2.1.1\\\"\\n//     }\\n//   }\\n// }\\n\" ));\n  }\n}\n\nvar _excluded$1 = [\"getMessageFallback\", \"messages\", \"onError\"];\n/**\r\n * Enhances the incoming props with defaults.\r\n */\nfunction getInitializedConfig(_ref) {\n  var getMessageFallback = _ref.getMessageFallback,\n    messages = _ref.messages,\n    onError = _ref.onError,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n  var finalOnError = onError || defaultOnError;\n  var finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n  {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n  return _extends({}, rest, {\n    messages: messages,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  });\n}\n\nvar _excluded = [\"children\"];\nfunction IntlProvider(_ref) {\n  var children = _ref.children,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  var _useState = React.useState(function () {\n      return new Map();\n    }),\n    messageFormatCache = _useState[0];\n  return React__default[\"default\"].createElement(IntlContext.Provider, {\n    value: _extends({}, getInitializedConfig(props), {\n      messageFormatCache: messageFormatCache\n    })\n  }, children);\n}\n\nfunction useIntlContext() {\n  var context = React.useContext(IntlContext);\n  if (!context) {\n    throw new Error('No intl context found. Have you configured the provider?' );\n  }\n  return context;\n}\n\nfunction useTranslationsImpl(allMessages, namespace, namespacePrefix) {\n  var _useIntlContext = useIntlContext(),\n    defaultTranslationValues = _useIntlContext.defaultTranslationValues,\n    globalFormats = _useIntlContext.formats,\n    getMessageFallback = _useIntlContext.getMessageFallback,\n    locale = _useIntlContext.locale,\n    messageFormatCache = _useIntlContext.messageFormatCache,\n    onError = _useIntlContext.onError,\n    timeZone = _useIntlContext.timeZone;\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  allMessages = allMessages[namespacePrefix];\n  namespace = resolveNamespace(namespace, namespacePrefix);\n  var messagesOrError = React.useMemo(function () {\n    return getMessagesOrError({\n      messages: allMessages,\n      namespace: namespace,\n      onError: onError\n    });\n  }, [allMessages, namespace, onError]);\n  var translate = React.useMemo(function () {\n    return createBaseTranslator({\n      messageFormatCache: messageFormatCache,\n      getMessageFallback: getMessageFallback,\n      messagesOrError: messagesOrError,\n      defaultTranslationValues: defaultTranslationValues,\n      namespace: namespace,\n      onError: onError,\n      formats: globalFormats,\n      locale: locale,\n      timeZone: timeZone\n    });\n  }, [messageFormatCache, getMessageFallback, messagesOrError, defaultTranslationValues, namespace, onError, globalFormats, locale, timeZone]);\n  return translate;\n}\n\n/**\r\n * Translates messages from the given namespace by using the ICU syntax.\r\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\r\n *\r\n * If no namespace is provided, all available messages are returned.\r\n * The namespace can also indicate nesting by using a dot\r\n * (e.g. `namespace.Component`).\r\n */\nfunction useTranslations(namespace) {\n  var context = useIntlContext();\n  var messages = context.messages;\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return useTranslationsImpl({\n    '!': messages\n  },\n  // @ts-expect-error\n  namespace ? \"!.\" + namespace : '!', '!');\n}\n\nfunction useLocale() {\n  return useIntlContext().locale;\n}\n\nfunction getNow() {\n  return new Date();\n}\n/**\r\n * Reading the current date via `new Date()` in components should be avoided, as\r\n * it causes components to be impure and can lead to flaky tests. Instead, this\r\n * hook can be used.\r\n *\r\n * By default, it returns the time when the component mounts. If `updateInterval`\r\n * is specified, the value will be updated based on the interval.\r\n *\r\n * You can however also return a static value from this hook, if you\r\n * configure the `now` parameter on the context provider. Note however,\r\n * that if `updateInterval` is configured in this case, the component\r\n * will initialize with the global value, but will afterwards update\r\n * continuously based on the interval.\r\n *\r\n * For unit tests, this can be mocked to a constant value. For end-to-end\r\n * testing, an environment parameter can be passed to the `now` parameter\r\n * of the provider to mock this to a static value.\r\n */\nfunction useNow(options) {\n  var updateInterval = options == null ? void 0 : options.updateInterval;\n  var _useIntlContext = useIntlContext(),\n    globalNow = _useIntlContext.now;\n  var _useState = React.useState(globalNow || getNow()),\n    now = _useState[0],\n    setNow = _useState[1];\n  React.useEffect(function () {\n    if (!updateInterval) return;\n    var intervalId = setInterval(function () {\n      setNow(getNow());\n    }, updateInterval);\n    return function () {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n  return now;\n}\n\nfunction useTimeZone() {\n  return useIntlContext().timeZone;\n}\n\nfunction useMessages() {\n  return useIntlContext().messages;\n}\n\nfunction useFormatter() {\n  var _useIntlContext = useIntlContext(),\n    formats = _useIntlContext.formats,\n    locale = _useIntlContext.locale,\n    globalNow = _useIntlContext.now,\n    onError = _useIntlContext.onError,\n    timeZone = _useIntlContext.timeZone;\n  return React.useMemo(function () {\n    return createFormatter({\n      formats: formats,\n      locale: locale,\n      now: globalNow,\n      onError: onError,\n      timeZone: timeZone\n    });\n  }, [formats, globalNow, locale, onError, timeZone]);\n}\n\nvar hasWarned = false;\n/** @deprecated Switch to `useFormatter` instead. */\nfunction useIntl() {\n  var _useIntlContext = useIntlContext(),\n    formats = _useIntlContext.formats,\n    locale = _useIntlContext.locale,\n    globalNow = _useIntlContext.now,\n    onError = _useIntlContext.onError,\n    timeZone = _useIntlContext.timeZone;\n  if (!hasWarned) {\n    hasWarned = true;\n    console.warn('`useIntl()` is deprecated and will be removed in the next major version. Please switch to `useFormatter()`.');\n  }\n  return React.useMemo(function () {\n    return createIntl({\n      formats: formats,\n      locale: locale,\n      now: globalNow,\n      onError: onError,\n      timeZone: timeZone\n    });\n  }, [formats, globalNow, locale, onError, timeZone]);\n}\n\nexports.IntlError = IntlError;\nexports.IntlProvider = IntlProvider;\nexports.createFormatter = createFormatter;\nexports.createIntl = createIntl;\nexports.createTranslator = createTranslator;\nexports.useFormatter = useFormatter;\nexports.useIntl = useIntl;\nexports.useLocale = useLocale;\nexports.useMessages = useMessages;\nexports.useNow = useNow;\nexports.useTimeZone = useTimeZone;\nexports.useTranslations = useTranslations;\n//# sourceMappingURL=use-intl.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC91c2UtaW50bC5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCx3QkFBd0IsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDcEQsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQixxQ0FBcUMsNERBQTREOztBQUVqRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLHFCQUFxQixLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pZnkvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC91c2UtaW50bC5janMuZGV2ZWxvcG1lbnQuanM/ODM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koSW50bE1lc3NhZ2VGb3JtYXQpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnRzLkludGxFcnJvckNvZGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG59KShleHBvcnRzLkludGxFcnJvckNvZGUgfHwgKGV4cG9ydHMuSW50bEVycm9yQ29kZSA9IHt9KSk7XG52YXIgSW50bEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW50bEVycm9yLCBfRXJyb3IpO1xuICBmdW5jdGlvbiBJbnRsRXJyb3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIF90aGlzLm9yaWdpbmFsTWVzc2FnZSA9IHZvaWQgMDtcbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBfdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICByZXR1cm4gSW50bEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuZnVuY3Rpb24gc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cywgdGltZVpvbmUpIHtcbiAgaWYgKCFmb3JtYXRzKSByZXR1cm4gZm9ybWF0cztcbiAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybWF0cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGFjY1trZXldID0gX2V4dGVuZHMoe1xuICAgICAgdGltZVpvbmU6IHRpbWVab25lXG4gICAgfSwgZm9ybWF0c1trZXldKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4vKipcclxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcclxuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cclxuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XHJcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxyXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChmb3JtYXRzLCB0aW1lWm9uZSkge1xuICB2YXIgZm9ybWF0c1dpdGhUaW1lWm9uZSA9IHRpbWVab25lID8gX2V4dGVuZHMoe30sIGZvcm1hdHMsIHtcbiAgICBkYXRlVGltZTogc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cy5kYXRlVGltZSwgdGltZVpvbmUpXG4gIH0pIDogZm9ybWF0cztcbiAgdmFyIG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZvcm1hdHMuZGF0ZTtcbiAgdmFyIGRlZmF1bHREYXRlRm9ybWF0cyA9IHRpbWVab25lID8gc2V0VGltZVpvbmVJbkZvcm1hdHMobWZEYXRlRGVmYXVsdHMsIHRpbWVab25lKSA6IG1mRGF0ZURlZmF1bHRzO1xuICB2YXIgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uZm9ybWF0cy50aW1lO1xuICB2YXIgZGVmYXVsdFRpbWVGb3JtYXRzID0gdGltZVpvbmUgPyBzZXRUaW1lWm9uZUluRm9ybWF0cyhtZlRpbWVEZWZhdWx0cywgdGltZVpvbmUpIDogbWZUaW1lRGVmYXVsdHM7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZm9ybWF0c1dpdGhUaW1lWm9uZSwge1xuICAgIGRhdGU6IF9leHRlbmRzKHt9LCBkZWZhdWx0RGF0ZUZvcm1hdHMsIGZvcm1hdHNXaXRoVGltZVpvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcm1hdHNXaXRoVGltZVpvbmUuZGF0ZVRpbWUpLFxuICAgIHRpbWU6IF9leHRlbmRzKHt9LCBkZWZhdWx0VGltZUZvcm1hdHMsIGZvcm1hdHNXaXRoVGltZVpvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcm1hdHNXaXRoVGltZVpvbmUuZGF0ZVRpbWUpXG4gIH0pO1xufVxuXG4vKipcclxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxyXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXHJcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gW3Byb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5XS5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydCAhPSBudWxsO1xuICB9KS5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKSB7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgYFwiICsgbmFtZXNwYWNlICsgXCJgLlwiICk7XG4gIH1cbiAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgYFwiICsga2V5ICsgXCJgIGluIFwiICsgKG5hbWVzcGFjZSA/IFwiYFwiICsgbmFtZXNwYWNlICsgXCJgXCIgOiAnbWVzc2FnZXMnKSArIFwiLlwiICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIHZhciB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgdmFyIHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gZnVuY3Rpb24gdHJhbnNmb3JtZWQoY2h1bmtzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IFJlYWN0LmNsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IoX3JlZikge1xuICB2YXIgbWVzc2FnZXMgPSBfcmVmLm1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlLFxuICAgIF9yZWYkb25FcnJvciA9IF9yZWYub25FcnJvcixcbiAgICBvbkVycm9yID0gX3JlZiRvbkVycm9yID09PSB2b2lkIDAgPyBkZWZhdWx0T25FcnJvciA6IF9yZWYkb25FcnJvcjtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgPyBcIk5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZCBvbiB0aGUgcHJvdmlkZXIuXCIgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YXIgcmV0cmlldmVkTWVzc2FnZXMgPSBuYW1lc3BhY2UgPyByZXNvbHZlUGF0aChtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuICAgIGlmICghcmV0cmlldmVkTWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyA/IFwiTm8gbWVzc2FnZXMgZm9yIG5hbWVzcGFjZSBgXCIgKyBuYW1lc3BhY2UgKyBcImAgZm91bmQuXCIgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cmlldmVkTWVzc2FnZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIGludGxFcnJvciA9IG5ldyBJbnRsRXJyb3IoZXhwb3J0cy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgdW5lc2NhcGVkTWVzc2FnZSA9IGNhbmRpZGF0ZS5yZXBsYWNlKC8nKFt7fV0pL2dpLCAnJDEnKTtcbiAgLy8gUGxhY2Vob2xkZXJzIGNhbiBiZSBpbiB0aGUgbWVzc2FnZSBpZiB0aGVyZSBhcmUgZGVmYXVsdCB2YWx1ZXMsXG4gIC8vIG9yIGlmIHRoZSB1c2VyIGhhcyBmb3Jnb3R0ZW4gdG8gcHJvdmlkZSB2YWx1ZXMuIEluIHRoZSBsYXR0ZXJcbiAgLy8gY2FzZSB3ZSBuZWVkIHRvIGNvbXBpbGUgdGhlIG1lc3NhZ2UgdG8gcmVjZWl2ZSBhbiBlcnJvci5cbiAgdmFyIGhhc1BsYWNlaG9sZGVycyA9IC88fHsvLnRlc3QodW5lc2NhcGVkTWVzc2FnZSk7XG4gIGlmICghaGFzUGxhY2Vob2xkZXJzKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKF9yZWYyKSB7XG4gIHZhciBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMgPSBfcmVmMi5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZ2xvYmFsRm9ybWF0cyA9IF9yZWYyLmZvcm1hdHMsXG4gICAgX3JlZjIkZ2V0TWVzc2FnZUZhbGxiID0gX3JlZjIuZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IF9yZWYyJGdldE1lc3NhZ2VGYWxsYiA9PT0gdm9pZCAwID8gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayA6IF9yZWYyJGdldE1lc3NhZ2VGYWxsYixcbiAgICBsb2NhbGUgPSBfcmVmMi5sb2NhbGUsXG4gICAgbWVzc2FnZUZvcm1hdENhY2hlID0gX3JlZjIubWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIG1lc3NhZ2VzT3JFcnJvciA9IF9yZWYyLm1lc3NhZ2VzT3JFcnJvcixcbiAgICBuYW1lc3BhY2UgPSBfcmVmMi5uYW1lc3BhY2UsXG4gICAgb25FcnJvciA9IF9yZWYyLm9uRXJyb3IsXG4gICAgdGltZVpvbmUgPSBfcmVmMi50aW1lWm9uZTtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEludGxFcnJvcihjb2RlLCBtZXNzYWdlKTtcbiAgICBvbkVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIGtleToga2V5LFxuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIEludGxFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdmFyIG1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBleHBvcnRzLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gam9pblBhdGgocGFydHMpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQgIT0gbnVsbDtcbiAgICAgIH0pLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgdmFyIGNhY2hlS2V5ID0gam9pblBhdGgoW2xvY2FsZSwgbmFtZXNwYWNlLCBrZXksIFN0cmluZyhtZXNzYWdlKV0pO1xuICAgIHZhciBtZXNzYWdlRm9ybWF0O1xuICAgIGlmIChtZXNzYWdlRm9ybWF0Q2FjaGUgIT0gbnVsbCAmJiBtZXNzYWdlRm9ybWF0Q2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IG1lc3NhZ2VGb3JtYXRDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBjb2RlLCBlcnJvck1lc3NhZ2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgY29kZSA9IGV4cG9ydHMuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJNZXNzYWdlIGF0IGBcIiArIGpvaW5QYXRoKFtuYW1lc3BhY2UsIGtleV0pICsgXCJgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IGV4cG9ydHMuSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiICsgam9pblBhdGgoW25hbWVzcGFjZSwga2V5XSkgKyBcImAgcmVzb2x2ZWQgdG8gYW4gb2JqZWN0LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFVzZSBhIGAuYCB0byByZXRyaWV2ZSBuZXN0ZWQgbWVzc2FnZXMuIFNlZSBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy91c2FnZS9tZXNzYWdlcyNzdHJ1Y3R1cmluZy1tZXNzYWdlc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgICAgdmFyIHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2VGb3JtYXQgPSBuZXcgSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKG1lc3NhZ2UsIGxvY2FsZSwgY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KF9leHRlbmRzKHt9LCBnbG9iYWxGb3JtYXRzLCBmb3JtYXRzKSwgdGltZVpvbmUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGV4cG9ydHMuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbWVzc2FnZUZvcm1hdENhY2hlID09IG51bGwgfHwgbWVzc2FnZUZvcm1hdENhY2hlLnNldChjYWNoZUtleSwgbWVzc2FnZUZvcm1hdCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWlnbm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMoX2V4dGVuZHMoe30sIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcywgdmFsdWVzKSkpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgPyBcIlVuYWJsZSB0byBmb3JtYXQgYFwiICsga2V5ICsgXCJgIGluIFwiICsgKG5hbWVzcGFjZSA/IFwibmFtZXNwYWNlIGBcIiArIG5hbWVzcGFjZSArIFwiYFwiIDogJ21lc3NhZ2VzJykgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIFJlYWN0LmlzVmFsaWRFbGVtZW50KGZvcm1hdHRlZE1lc3NhZ2UpIHx8XG4gICAgICAvLyBBcnJheXMgb2YgUmVhY3QgZWxlbWVudHNcbiAgICAgIEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkTWVzc2FnZSkgfHwgdHlwZW9mIGZvcm1hdHRlZE1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZm9ybWF0dGVkTWVzc2FnZSA6IFN0cmluZyhmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgZXhwb3J0cy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVGbiggLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGV4cG9ydHMuSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIFwiVGhlIG1lc3NhZ2UgYFwiICsga2V5ICsgXCJgIGluIFwiICsgKG5hbWVzcGFjZSA/IFwibmFtZXNwYWNlIGBcIiArIG5hbWVzcGFjZSArIFwiYFwiIDogJ21lc3NhZ2VzJykgKyBcIiBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIGB0LnJpY2hgIGluc3RlYWQuXCIgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuICB0cmFuc2xhdGVGbi5yYXcgPSBmdW5jdGlvbiAoIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5KSB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIEludGxFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBleHBvcnRzLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXHJcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXHJcbiAqIGEgbWFuZGF0b3J5IHByZWZpeC4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcclxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJnZXRNZXNzYWdlRmFsbGJhY2tcIiwgXCJtZXNzYWdlc1wiLCBcIm5hbWVzcGFjZVwiLCBcIm9uRXJyb3JcIl07XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2xhdG9ySW1wbChfcmVmLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgdmFyIGdldE1lc3NhZ2VGYWxsYmFjayA9IF9yZWYuZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzID0gX3JlZi5tZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UgPSBfcmVmLm5hbWVzcGFjZSxcbiAgICBvbkVycm9yID0gX3JlZi5vbkVycm9yLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkMyk7XG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxuICBtZXNzYWdlcyA9IG1lc3NhZ2VzW25hbWVzcGFjZVByZWZpeF07XG4gIG5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpO1xuICB2YXIgdHJhbnNsYXRvciA9IGNyZWF0ZUJhc2VUcmFuc2xhdG9yKF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgb25FcnJvcjogb25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlc09yRXJyb3I6IGdldE1lc3NhZ2VzT3JFcnJvcih7XG4gICAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICB9KVxuICB9KSk7XG4gIHZhciBvcmlnaW5hbFJpY2ggPSB0cmFuc2xhdG9yLnJpY2g7XG4gIGZ1bmN0aW9uIGJhc2UoKSB7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3IuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9XG4gIC8vIEF1Z21lbnQgYHQucmljaGAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgYmFzZS5yaWNoID0gZnVuY3Rpb24gKGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgZm9ybWF0cykge1xuICAgIC8vIGBjaHVua3NgIGlzIHJldHVybmVkIGFzIGEgc3RyaW5nIHdoZW4gbm8gUmVhY3QgZWxlbWVudFxuICAgIC8vIGlzIHVzZWQsIHRoZXJlZm9yZSBpdCdzIHNhZmUgdG8gY2FzdCB0aGlzIHR5cGUuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsUmljaChrZXksIHZhbHVlcywgZm9ybWF0cyk7XG4gICAgLy8gV2hlbiBvbmx5IHN0cmluZyBjaHVua3MgYXJlIHByb3ZpZGVkIHRvIHRoZSBwYXJzZXIsIG9ubHkgc3RyaW5ncyBzaG91bGQgYmUgcmV0dXJuZWQgaGVyZS5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBJbnRsRXJyb3IoZXhwb3J0cy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIFwiYGNyZWF0ZVRyYW5zbGF0b3JgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIHJpY2ggdGV4dCBmb3JtYXR0aW5nIHRoYXQgcmVjZWl2ZSBhbmQgcmV0dXJuIHN0cmluZ3MuXFxuXFxuRS5nLiB0LnJpY2goJ3JpY2gnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIiApO1xuICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBiYXNlLnJhdyA9IHRyYW5zbGF0b3IucmF3O1xuICByZXR1cm4gYmFzZTtcbn1cblxudmFyIF9leGNsdWRlZCQyID0gW1wiZ2V0TWVzc2FnZUZhbGxiYWNrXCIsIFwibWVzc2FnZXNcIiwgXCJuYW1lc3BhY2VcIiwgXCJvbkVycm9yXCJdO1xuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxyXG4gKiBTZWUgaHR0cHM6Ly9mb3JtYXRqcy5pby9kb2NzL2NvcmUtY29uY2VwdHMvaWN1LXN5bnRheC5cclxuICpcclxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cclxuICogVGhlIG5hbWVzcGFjZSBjYW4gYWxzbyBpbmRpY2F0ZSBuZXN0aW5nIGJ5IHVzaW5nIGEgZG90XHJcbiAqIChlLmcuIGBuYW1lc3BhY2UuQ29tcG9uZW50YCkuXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcihfcmVmKSB7XG4gIHZhciBfcmVmJGdldE1lc3NhZ2VGYWxsYmEgPSBfcmVmLmdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBfcmVmJGdldE1lc3NhZ2VGYWxsYmEgPT09IHZvaWQgMCA/IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgOiBfcmVmJGdldE1lc3NhZ2VGYWxsYmEsXG4gICAgbWVzc2FnZXMgPSBfcmVmLm1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlLFxuICAgIF9yZWYkb25FcnJvciA9IF9yZWYub25FcnJvcixcbiAgICBvbkVycm9yID0gX3JlZiRvbkVycm9yID09PSB2b2lkIDAgPyBkZWZhdWx0T25FcnJvciA6IF9yZWYkb25FcnJvcixcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJDIpO1xuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBmdW5jdGlvbiBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gY3JlYXRlVHJhbnNsYXRvckltcGwoX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAnISc6IG1lc3NhZ2VzXG4gICAgfSxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSA/IFwiIS5cIiArIG5hbWVzcGFjZSA6ICchJ1xuICB9KSwgJyEnKTtcbn1cblxudmFyIFNFQ09ORCA9IDE7XG52YXIgTUlOVVRFID0gU0VDT05EICogNjA7XG52YXIgSE9VUiA9IE1JTlVURSAqIDYwO1xudmFyIERBWSA9IEhPVVIgKiAyNDtcbnZhciBXRUVLID0gREFZICogNztcbnZhciBNT05USCA9IERBWSAqICgzNjUgLyAxMik7IC8vIEFwcHJveGltYXRpb25cbnZhciBRVUFSVEVSID0gTU9OVEggKiAzO1xudmFyIFlFQVIgPSBEQVkgKiAzNjU7XG52YXIgVU5JVF9TRUNPTkRTID0ge1xuICBzZWNvbmQ6IFNFQ09ORCxcbiAgc2Vjb25kczogU0VDT05ELFxuICBtaW51dGU6IE1JTlVURSxcbiAgbWludXRlczogTUlOVVRFLFxuICBob3VyOiBIT1VSLFxuICBob3VyczogSE9VUixcbiAgZGF5OiBEQVksXG4gIGRheXM6IERBWSxcbiAgd2VlazogV0VFSyxcbiAgd2Vla3M6IFdFRUssXG4gIG1vbnRoOiBNT05USCxcbiAgbW9udGhzOiBNT05USCxcbiAgcXVhcnRlcjogUVVBUlRFUixcbiAgcXVhcnRlcnM6IFFVQVJURVIsXG4gIHllYXI6IFlFQVIsXG4gIHllYXJzOiBZRUFSXG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykge1xuICB2YXIgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoX3JlZikge1xuICB2YXIgZm9ybWF0cyA9IF9yZWYuZm9ybWF0cyxcbiAgICBsb2NhbGUgPSBfcmVmLmxvY2FsZSxcbiAgICBnbG9iYWxOb3cgPSBfcmVmLm5vdyxcbiAgICBfcmVmJG9uRXJyb3IgPSBfcmVmLm9uRXJyb3IsXG4gICAgb25FcnJvciA9IF9yZWYkb25FcnJvciA9PT0gdm9pZCAwID8gZGVmYXVsdE9uRXJyb3IgOiBfcmVmJG9uRXJyb3IsXG4gICAgZ2xvYmFsVGltZVpvbmUgPSBfcmVmLnRpbWVab25lO1xuICBmdW5jdGlvbiByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZvcm1hdE9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzID09IG51bGwgPyB2b2lkIDAgOiB0eXBlRm9ybWF0c1tmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgSW50bEVycm9yKGV4cG9ydHMuSW50bEVycm9yQ29kZS5NSVNTSU5HX0ZPUk1BVCwgXCJGb3JtYXQgYFwiICsgZm9ybWF0TmFtZSArIFwiYCBpcyBub3QgYXZhaWxhYmxlLiBZb3UgY2FuIGNvbmZpZ3VyZSBpdCBvbiB0aGUgcHJvdmlkZXIgb3IgcHJvdmlkZSBjdXN0b20gb3B0aW9ucy5cIiApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIHR5cGVGb3JtYXRzLCBmb3JtYXR0ZXIpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKGV4cG9ydHMuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUoIC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHZhbHVlLFxuICAvKiogSWYgYSB0aW1lIHpvbmUgaXMgc3VwcGxpZWQsIHRoZSBgdmFsdWVgIGlzIGNvbnZlcnRlZCB0byB0aGF0IHRpbWUgem9uZS5cclxuICAgKiBPdGhlcndpc2UgdGhlIHVzZXIgdGltZSB6b25lIHdpbGwgYmUgdXNlZC4gKi9cbiAgZm9ybWF0T3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcm1hdHMuZGF0ZVRpbWUsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgX29wdGlvbnM7XG4gICAgICBpZiAoISgoX29wdGlvbnMgPSBvcHRpb25zKSAhPSBudWxsICYmIF9vcHRpb25zLnRpbWVab25lKSkge1xuICAgICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgICBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihleHBvcnRzLkludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nID8gXCJUaGUgYHRpbWVab25lYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lXCIgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIodmFsdWUsIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09IG51bGwgPyB2b2lkIDAgOiBmb3JtYXRzLm51bWJlciwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICBpZiAoZ2xvYmFsTm93KSB7XG4gICAgICByZXR1cm4gZ2xvYmFsTm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoZXhwb3J0cy5JbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBcIlRoZSBgbm93YCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jbm93XCIgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdE5vd0RhdGUobm93T3JPcHRpb25zKSB7XG4gICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoKG5vd09yT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbm93T3JPcHRpb25zLm5vdykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R2xvYmFsTm93KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKCAvKiogVGhlIGRhdGUgdGltZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZC4gKi9cbiAgZGF0ZSwgLyoqIFRoZSByZWZlcmVuY2UgcG9pbnQgaW4gdGltZSB0byB3aGljaCBgZGF0ZWAgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gcmVsYXRpb24gdG8uICAqL1xuICBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB2YXIgbm93RGF0ZSA9IGV4dHJhY3ROb3dEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgICB2YXIgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgdmFyIHVuaXQgPSB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJyB8fCBub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IChub3dPck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG5vd09yT3B0aW9ucy51bml0KSA9PT0gdW5kZWZpbmVkID8gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykgOiBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgIHZhciB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgbnVtZXJpYzogJ2F1dG8nXG4gICAgICB9KS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoZXhwb3J0cy5JbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3QodmFsdWUsIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09IG51bGwgPyB2b2lkIDAgOiBmb3JtYXRzLmxpc3QsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuTGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZTogZGF0ZVRpbWUsXG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lOiByZWxhdGl2ZVRpbWUsXG4gICAgbGlzdDogbGlzdFxuICB9O1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgU3dpdGNoIHRvIGBjcmVhdGVGb3JtYXR0ZXJgICovXG5mdW5jdGlvbiBjcmVhdGVJbnRsKCkge1xuICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXREYXRlVGltZTogZm9ybWF0dGVyLmRhdGVUaW1lLFxuICAgIGZvcm1hdE51bWJlcjogZm9ybWF0dGVyLm51bWJlcixcbiAgICBmb3JtYXRSZWxhdGl2ZVRpbWU6IGZvcm1hdHRlci5yZWxhdGl2ZVRpbWVcbiAgfTtcbn1cblxudmFyIEludGxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgIG1lc3NhZ2VPck1lc3NhZ2VzID0gX3JlZlsxXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIHZhciBrZXlMYWJlbCA9IGtleTtcbiAgICAgIGlmIChwYXJlbnRQYXRoKSBrZXlMYWJlbCArPSBcIiAoYXQgXCIgKyBwYXJlbnRQYXRoICsgXCIpXCI7XG4gICAgICBpbnZhbGlkS2V5TGFiZWxzLnB1c2goa2V5TGFiZWwpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgW3BhcmVudFBhdGgsIGtleV0uZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0ICE9IG51bGw7XG4gICAgICB9KS5qb2luKCcuJykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvbkVycm9yKSB7XG4gIHZhciBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihleHBvcnRzLkludGxFcnJvckNvZGUuSU5WQUxJRF9LRVksIFwiTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXFxcIi5cXFwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxcblxcbkludmFsaWQgXCIgKyAoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJykgKyBcIjogXCIgKyBpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJykgKyBcIlxcblxcbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxcblxcbmltcG9ydCB7c2V0fSBmcm9tIFxcXCJsb2Rhc2hcXFwiO1xcblxcbmNvbnN0IGlucHV0ID0ge1xcbiAgXFxcIm9uZS5vbmVcXFwiOiBcXFwiMS4xXFxcIixcXG4gIFxcXCJvbmUudHdvXFxcIjogXFxcIjEuMlxcXCIsXFxuICBcXFwidHdvLm9uZS5vbmVcXFwiOiBcXFwiMi4xLjFcXFwiXFxufTtcXG5cXG5jb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKFxcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcXG4gIHt9XFxuKTtcXG5cXG4vLyBPdXRwdXQ6XFxuLy9cXG4vLyB7XFxuLy8gICBcXFwib25lXFxcIjoge1xcbi8vICAgICBcXFwib25lXFxcIjogXFxcIjEuMVxcXCIsXFxuLy8gICAgIFxcXCJ0d29cXFwiOiBcXFwiMS4yXFxcIlxcbi8vICAgfSxcXG4vLyAgIFxcXCJ0d29cXFwiOiB7XFxuLy8gICAgIFxcXCJvbmVcXFwiOiB7XFxuLy8gICAgICAgXFxcIm9uZVxcXCI6IFxcXCIyLjEuMVxcXCJcXG4vLyAgICAgfVxcbi8vICAgfVxcbi8vIH1cXG5cIiApKTtcbiAgfVxufVxuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJnZXRNZXNzYWdlRmFsbGJhY2tcIiwgXCJtZXNzYWdlc1wiLCBcIm9uRXJyb3JcIl07XG4vKipcclxuICogRW5oYW5jZXMgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMuXHJcbiAqL1xuZnVuY3Rpb24gZ2V0SW5pdGlhbGl6ZWRDb25maWcoX3JlZikge1xuICB2YXIgZ2V0TWVzc2FnZUZhbGxiYWNrID0gX3JlZi5nZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMgPSBfcmVmLm1lc3NhZ2VzLFxuICAgIG9uRXJyb3IgPSBfcmVmLm9uRXJyb3IsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQxKTtcbiAgdmFyIGZpbmFsT25FcnJvciA9IG9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gIHZhciBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfSk7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIEludGxQcm92aWRlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9KSxcbiAgICBtZXNzYWdlRm9ybWF0Q2FjaGUgPSBfdXNlU3RhdGVbMF07XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChJbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBfZXh0ZW5kcyh7fSwgZ2V0SW5pdGlhbGl6ZWRDb25maWcocHJvcHMpLCB7XG4gICAgICBtZXNzYWdlRm9ybWF0Q2FjaGU6IG1lc3NhZ2VGb3JtYXRDYWNoZVxuICAgIH0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gdXNlSW50bENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gaW50bCBjb250ZXh0IGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZSBwcm92aWRlcj8nICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9uc0ltcGwoYWxsTWVzc2FnZXMsIG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHZhciBfdXNlSW50bENvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpLFxuICAgIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcyA9IF91c2VJbnRsQ29udGV4dC5kZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZ2xvYmFsRm9ybWF0cyA9IF91c2VJbnRsQ29udGV4dC5mb3JtYXRzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayA9IF91c2VJbnRsQ29udGV4dC5nZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlID0gX3VzZUludGxDb250ZXh0LmxvY2FsZSxcbiAgICBtZXNzYWdlRm9ybWF0Q2FjaGUgPSBfdXNlSW50bENvbnRleHQubWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIG9uRXJyb3IgPSBfdXNlSW50bENvbnRleHQub25FcnJvcixcbiAgICB0aW1lWm9uZSA9IF91c2VJbnRsQ29udGV4dC50aW1lWm9uZTtcbiAgLy8gVGhlIGBuYW1lc3BhY2VQcmVmaXhgIGlzIHBhcnQgb2YgdGhlIHR5cGUgc3lzdGVtLlxuICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIGhvb2sgaW52b2NhdGlvbi5cbiAgYWxsTWVzc2FnZXMgPSBhbGxNZXNzYWdlc1tuYW1lc3BhY2VQcmVmaXhdO1xuICBuYW1lc3BhY2UgPSByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KTtcbiAgdmFyIG1lc3NhZ2VzT3JFcnJvciA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlc09yRXJyb3Ioe1xuICAgICAgbWVzc2FnZXM6IGFsbE1lc3NhZ2VzLFxuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgfSk7XG4gIH0sIFthbGxNZXNzYWdlcywgbmFtZXNwYWNlLCBvbkVycm9yXSk7XG4gIHZhciB0cmFuc2xhdGUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgICAgbWVzc2FnZUZvcm1hdENhY2hlOiBtZXNzYWdlRm9ybWF0Q2FjaGUsXG4gICAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAgIG1lc3NhZ2VzT3JFcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzOiBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICB0aW1lWm9uZTogdGltZVpvbmVcbiAgICB9KTtcbiAgfSwgW21lc3NhZ2VGb3JtYXRDYWNoZSwgZ2V0TWVzc2FnZUZhbGxiYWNrLCBtZXNzYWdlc09yRXJyb3IsIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcywgbmFtZXNwYWNlLCBvbkVycm9yLCBnbG9iYWxGb3JtYXRzLCBsb2NhbGUsIHRpbWVab25lXSk7XG4gIHJldHVybiB0cmFuc2xhdGU7XG59XG5cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIG1lc3NhZ2VzIGZyb20gdGhlIGdpdmVuIG5hbWVzcGFjZSBieSB1c2luZyB0aGUgSUNVIHN5bnRheC5cclxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXHJcbiAqXHJcbiAqIElmIG5vIG5hbWVzcGFjZSBpcyBwcm92aWRlZCwgYWxsIGF2YWlsYWJsZSBtZXNzYWdlcyBhcmUgcmV0dXJuZWQuXHJcbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxyXG4gKiAoZS5nLiBgbmFtZXNwYWNlLkNvbXBvbmVudGApLlxyXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9ucyhuYW1lc3BhY2UpIHtcbiAgdmFyIGNvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpO1xuICB2YXIgbWVzc2FnZXMgPSBjb250ZXh0Lm1lc3NhZ2VzO1xuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBob29rIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIHJldHVybiB1c2VUcmFuc2xhdGlvbnNJbXBsKHtcbiAgICAnISc6IG1lc3NhZ2VzXG4gIH0sXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbmFtZXNwYWNlID8gXCIhLlwiICsgbmFtZXNwYWNlIDogJyEnLCAnIScpO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbGUoKSB7XG4gIHJldHVybiB1c2VJbnRsQ29udGV4dCgpLmxvY2FsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cbi8qKlxyXG4gKiBSZWFkaW5nIHRoZSBjdXJyZW50IGRhdGUgdmlhIGBuZXcgRGF0ZSgpYCBpbiBjb21wb25lbnRzIHNob3VsZCBiZSBhdm9pZGVkLCBhc1xyXG4gKiBpdCBjYXVzZXMgY29tcG9uZW50cyB0byBiZSBpbXB1cmUgYW5kIGNhbiBsZWFkIHRvIGZsYWt5IHRlc3RzLiBJbnN0ZWFkLCB0aGlzXHJcbiAqIGhvb2sgY2FuIGJlIHVzZWQuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIGl0IHJldHVybnMgdGhlIHRpbWUgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy4gSWYgYHVwZGF0ZUludGVydmFsYFxyXG4gKiBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gdGhlIGludGVydmFsLlxyXG4gKlxyXG4gKiBZb3UgY2FuIGhvd2V2ZXIgYWxzbyByZXR1cm4gYSBzdGF0aWMgdmFsdWUgZnJvbSB0aGlzIGhvb2ssIGlmIHlvdVxyXG4gKiBjb25maWd1cmUgdGhlIGBub3dgIHBhcmFtZXRlciBvbiB0aGUgY29udGV4dCBwcm92aWRlci4gTm90ZSBob3dldmVyLFxyXG4gKiB0aGF0IGlmIGB1cGRhdGVJbnRlcnZhbGAgaXMgY29uZmlndXJlZCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnRcclxuICogd2lsbCBpbml0aWFsaXplIHdpdGggdGhlIGdsb2JhbCB2YWx1ZSwgYnV0IHdpbGwgYWZ0ZXJ3YXJkcyB1cGRhdGVcclxuICogY29udGludW91c2x5IGJhc2VkIG9uIHRoZSBpbnRlcnZhbC5cclxuICpcclxuICogRm9yIHVuaXQgdGVzdHMsIHRoaXMgY2FuIGJlIG1vY2tlZCB0byBhIGNvbnN0YW50IHZhbHVlLiBGb3IgZW5kLXRvLWVuZFxyXG4gKiB0ZXN0aW5nLCBhbiBlbnZpcm9ubWVudCBwYXJhbWV0ZXIgY2FuIGJlIHBhc3NlZCB0byB0aGUgYG5vd2AgcGFyYW1ldGVyXHJcbiAqIG9mIHRoZSBwcm92aWRlciB0byBtb2NrIHRoaXMgdG8gYSBzdGF0aWMgdmFsdWUuXHJcbiAqL1xuZnVuY3Rpb24gdXNlTm93KG9wdGlvbnMpIHtcbiAgdmFyIHVwZGF0ZUludGVydmFsID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51cGRhdGVJbnRlcnZhbDtcbiAgdmFyIF91c2VJbnRsQ29udGV4dCA9IHVzZUludGxDb250ZXh0KCksXG4gICAgZ2xvYmFsTm93ID0gX3VzZUludGxDb250ZXh0Lm5vdztcbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSksXG4gICAgbm93ID0gX3VzZVN0YXRlWzBdLFxuICAgIHNldE5vdyA9IF91c2VTdGF0ZVsxXTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXVwZGF0ZUludGVydmFsKSByZXR1cm47XG4gICAgdmFyIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gbm93O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkudGltZVpvbmU7XG59XG5cbmZ1bmN0aW9uIHVzZU1lc3NhZ2VzKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS5tZXNzYWdlcztcbn1cblxuZnVuY3Rpb24gdXNlRm9ybWF0dGVyKCkge1xuICB2YXIgX3VzZUludGxDb250ZXh0ID0gdXNlSW50bENvbnRleHQoKSxcbiAgICBmb3JtYXRzID0gX3VzZUludGxDb250ZXh0LmZvcm1hdHMsXG4gICAgbG9jYWxlID0gX3VzZUludGxDb250ZXh0LmxvY2FsZSxcbiAgICBnbG9iYWxOb3cgPSBfdXNlSW50bENvbnRleHQubm93LFxuICAgIG9uRXJyb3IgPSBfdXNlSW50bENvbnRleHQub25FcnJvcixcbiAgICB0aW1lWm9uZSA9IF91c2VJbnRsQ29udGV4dC50aW1lWm9uZTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbm93OiBnbG9iYWxOb3csXG4gICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgdGltZVpvbmU6IHRpbWVab25lXG4gICAgfSk7XG4gIH0sIFtmb3JtYXRzLCBnbG9iYWxOb3csIGxvY2FsZSwgb25FcnJvciwgdGltZVpvbmVdKTtcbn1cblxudmFyIGhhc1dhcm5lZCA9IGZhbHNlO1xuLyoqIEBkZXByZWNhdGVkIFN3aXRjaCB0byBgdXNlRm9ybWF0dGVyYCBpbnN0ZWFkLiAqL1xuZnVuY3Rpb24gdXNlSW50bCgpIHtcbiAgdmFyIF91c2VJbnRsQ29udGV4dCA9IHVzZUludGxDb250ZXh0KCksXG4gICAgZm9ybWF0cyA9IF91c2VJbnRsQ29udGV4dC5mb3JtYXRzLFxuICAgIGxvY2FsZSA9IF91c2VJbnRsQ29udGV4dC5sb2NhbGUsXG4gICAgZ2xvYmFsTm93ID0gX3VzZUludGxDb250ZXh0Lm5vdyxcbiAgICBvbkVycm9yID0gX3VzZUludGxDb250ZXh0Lm9uRXJyb3IsXG4gICAgdGltZVpvbmUgPSBfdXNlSW50bENvbnRleHQudGltZVpvbmU7XG4gIGlmICghaGFzV2FybmVkKSB7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oJ2B1c2VJbnRsKClgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBQbGVhc2Ugc3dpdGNoIHRvIGB1c2VGb3JtYXR0ZXIoKWAuJyk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVJbnRsKHtcbiAgICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIG5vdzogZ2xvYmFsTm93LFxuICAgICAgb25FcnJvcjogb25FcnJvcixcbiAgICAgIHRpbWVab25lOiB0aW1lWm9uZVxuICAgIH0pO1xuICB9LCBbZm9ybWF0cywgZ2xvYmFsTm93LCBsb2NhbGUsIG9uRXJyb3IsIHRpbWVab25lXSk7XG59XG5cbmV4cG9ydHMuSW50bEVycm9yID0gSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsUHJvdmlkZXIgPSBJbnRsUHJvdmlkZXI7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlSW50bCA9IGNyZWF0ZUludGw7XG5leHBvcnRzLmNyZWF0ZVRyYW5zbGF0b3IgPSBjcmVhdGVUcmFuc2xhdG9yO1xuZXhwb3J0cy51c2VGb3JtYXR0ZXIgPSB1c2VGb3JtYXR0ZXI7XG5leHBvcnRzLnVzZUludGwgPSB1c2VJbnRsO1xuZXhwb3J0cy51c2VMb2NhbGUgPSB1c2VMb2NhbGU7XG5leHBvcnRzLnVzZU1lc3NhZ2VzID0gdXNlTWVzc2FnZXM7XG5leHBvcnRzLnVzZU5vdyA9IHVzZU5vdztcbmV4cG9ydHMudXNlVGltZVpvbmUgPSB1c2VUaW1lWm9uZTtcbmV4cG9ydHMudXNlVHJhbnNsYXRpb25zID0gdXNlVHJhbnNsYXRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGwuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/use-intl.cjs.development.js\n");

/***/ })

};
;